name: cleanup-once
on:
  workflow_dispatch: {}
env:
  AWS_REGION: us-east-1
  ACCOUNT_ID: "156041402173"
  CLUSTER_NAME: devsecops
  ECR_REPO: devsecops
  BUCKET_APP: devsecops-156041402173-us-east-1
  TF_STATE_KEY: tfstate/infra.tfstate
  TF_LOCK_TABLE: terraform-locks
  VPC_NAME_PRIMARY: devsecops-vpc
  VPC_NAME_SECONDARY: devsecops
  ROLE_GH: devsecops-github-actions-role
  ROLE_CLUSTER: devsecops-eks-cluster-role
  ROLE_NODE: devsecops-eks-cluster-node-role
  POLICY_GH: devsecops-github-actions-role-policy
  KMS_ALIAS: alias/eks/devsecops
  CW_LOG_GROUP: /aws/eks/devsecops/cluster
permissions:
  id-token: write
  contents: read
jobs:
  nuke:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS (use your terraform role)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::156041402173:role/devsecops-terraform-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Delete k8s LBs/TGs (best effort)
        run: |
          set -euo pipefail
          TGs=$(aws elbv2 describe-target-groups --query "TargetGroups[?contains(TargetGroupName, '${CLUSTER_NAME}')].TargetGroupArn" --output text || true)
          for tg in $TGs; do aws elbv2 delete-target-group --target-group-arn "$tg" || true; done
          LBs=$(aws elbv2 describe-load-balancers --query "LoadBalancers[?contains(LoadBalancerName, '${CLUSTER_NAME}')].LoadBalancerArn" --output text || true)
          for lb in $LBs; do aws elbv2 delete-load-balancer --load-balancer-arn "$lb" || true; done

      - name: Delete EKS cluster & nodegroups
        run: |
          set -euo pipefail
          if aws eks describe-cluster --name "$CLUSTER_NAME" >/dev/null 2>&1; then
            NGS=$(aws eks list-nodegroups --cluster-name "$CLUSTER_NAME" --query 'nodegroups[]' --output text)
            for ng in $NGS; do aws eks delete-nodegroup --cluster-name "$CLUSTER_NAME" --nodegroup-name "$ng" || true; done
            for ng in $NGS; do aws eks wait nodegroup-deleted --cluster-name "$CLUSTER_NAME" --nodegroup-name "$ng" || true; done
            aws eks delete-cluster --name "$CLUSTER_NAME" || true
            aws eks wait cluster-deleted --name "$CLUSTER_NAME" || true
          fi

      - name: Delete CloudWatch log group & KMS alias/key
        run: |
          set -euo pipefail
          aws logs delete-log-group --log-group-name "$CW_LOG_GROUP" >/dev/null 2>&1 || true
          if aws kms list-aliases --query "Aliases[?AliasName=='$KMS_ALIAS']" --output text | grep -q "$KMS_ALIAS"; then
            KEY_ID=$(aws kms describe-key --key-id "$KMS_ALIAS" --query 'KeyMetadata.KeyId' --output text 2>/dev/null || true)
            aws kms delete-alias --alias-name "$KMS_ALIAS" >/dev/null 2>&1 || true
            if [ -n "${KEY_ID:-}" ] && [ "$KEY_ID" != "None" ]; then
              aws kms disable-key --key-id "$KEY_ID" || true
              aws kms schedule-key-deletion --key-id "$KEY_ID" --pending-window-in-days 7 || true
            fi
          fi

      - name: Delete ECR repo (force)
        run: |
          set -euo pipefail
          if aws ecr describe-repositories --repository-names "$ECR_REPO" >/dev/null 2>&1; then
            IDS=$(aws ecr list-images --repository-name "$ECR_REPO" --query 'imageIds[*]' --output json)
            if [ "$(echo "$IDS" | jq 'length' 2>/dev/null || echo 0)" != "0" ]; then
              aws ecr batch-delete-image --repository-name "$ECR_REPO" --image-ids "$IDS" || true
            fi
            aws ecr delete-repository --repository-name "$ECR_REPO" --force || true
          fi

      - name: Delete S3 app/tfstate bucket + DynamoDB lock table
        run: |
          set -euo pipefail
          LOCK_KEY="${BUCKET_APP}/${TF_STATE_KEY}"
          aws dynamodb delete-item --table-name "$TF_LOCK_TABLE" --key "{\"LockID\":{\"S\":\"$LOCK_KEY\"}}" >/dev/null 2>&1 || true
          if aws s3api head-bucket --bucket "$BUCKET_APP" >/dev/null 2>&1; then
            aws s3 rm "s3://$BUCKET_APP/tfstate/" --recursive >/dev/null 2>&1 || true
            aws s3 rm "s3://$BUCKET_APP/" --recursive >/dev/null 2>&1 || true
            aws s3api delete-bucket --bucket "$BUCKET_APP" --region "$AWS_REGION" || true
          fi
          aws dynamodb delete-table --table-name "$TF_LOCK_TABLE" >/dev/null 2>&1 || true

      - name: Delete IAM roles/policies
        run: |
          set -euo pipefail
          if aws iam get-policy --policy-arn "arn:aws:iam::$ACCOUNT_ID:policy/$POLICY_GH" >/dev/null 2>&1; then
            aws iam detach-role-policy --role-name "$ROLE_GH" --policy-arn "arn:aws:iam::$ACCOUNT_ID:policy/$POLICY_GH" >/dev/null 2>&1 || true
            aws iam delete-policy --policy-arn "arn:aws:iam::$ACCOUNT_ID:policy/$POLICY_GH" >/dev/null 2>&1 || true
          fi
          for R in "$ROLE_GH" "$ROLE_NODE" "$ROLE_CLUSTER"; do
            if aws iam get-role --role-name "$R" >/dev/null 2>&1; then
              ARNS=$(aws iam list-attached-role-policies --role-name "$R" --query 'AttachedPolicies[].PolicyArn' --output text)
              for p in $ARNS; do aws iam detach-role-policy --role-name "$R" --policy-arn "$p" || true; done
              aws iam delete-role --role-name "$R" || true
            fi
          done

      - name: Delete VPCs (devsecops-vpc and devsecops)
        run: |
          set -euo pipefail
          delete_vpc() {
            NAME="$1"
            VPC_ID=$(aws ec2 describe-vpcs --filters Name=tag:Name,Values="$NAME" --query 'Vpcs[0].VpcId' --output text 2>/dev/null || true)
            [ -z "$VPC_ID" ] || [ "$VPC_ID" = "None" ] && { echo "VPC $NAME not found (ok)"; return 0; }
            echo "Cleaning VPC $NAME ($VPC_ID)"

            EP_IDS=$(aws ec2 describe-vpc-endpoints --filters Name=vpc-id,Values="$VPC_ID" --query 'VpcEndpoints[].VpcEndpointId' --output text || true)
            for id in $EP_IDS; do aws ec2 delete-vpc-endpoints --vpc-endpoint-ids "$id" || true; done

            NGWS=$(aws ec2 describe-nat-gateways --filter Name=vpc-id,Values="$VPC_ID" --query 'NatGateways[].NatGatewayId' --output text || true)
            for ng in $NGWS; do aws ec2 delete-nat-gateway --nat-gateway-id "$ng" || true; done
            sleep 10
            ALLOC_IDS=$(aws ec2 describe-addresses --filters Name=domain,Values=vpc --query 'Addresses[].AllocationId' --output text || true)
            for a in $ALLOC_IDS; do aws ec2 release-address --allocation-id "$a" || true; done

            IGWS=$(aws ec2 describe-internet-gateways --filters Name=attachment.vpc-id,Values="$VPC_ID" --query 'InternetGateways[].InternetGatewayId' --output text || true)
            for igw in $IGWS; do aws ec2 detach-internet-gateway --internet-gateway-id "$igw" --vpc-id "$VPC_ID" || true; aws ec2 delete-internet-gateway --internet-gateway-id "$igw" || true; done

            LBS=$(aws elbv2 describe-load-balancers --query "LoadBalancers[?VpcId=='$VPC_ID'].LoadBalancerArn" --output text || true)
            for lb in $LBS; do aws elbv2 delete-load-balancer --load-balancer-arn "$lb" || true; done
            TGS=$(aws elbv2 describe-target-groups --query "TargetGroups[?VpcId=='$VPC_ID'].TargetGroupArn" --output text || true)
            for tg in $TGS; do aws elbv2 delete-target-group --target-group-arn "$tg" || true; done

            MAIN=$(aws ec2 describe-route-tables --filters Name=vpc-id,Values="$VPC_ID" Name=association.main,Values=true --query 'RouteTables[0].RouteTableId' --output text || true)
            ALL=$(aws ec2 describe-route-tables --filters Name=vpc-id,Values="$VPC_ID" --query 'RouteTables[].RouteTableId' --output text || true)
            for rtb in $ALL; do
              [ "$rtb" = "$MAIN" ] && continue
              ASSOCS=$(aws ec2 describe-route-tables --route-table-ids "$rtb" --query 'RouteTables[0].Associations[].RouteTableAssociationId' --output text || true)
              for a in $ASSOCS; do aws ec2 disassociate-route-table --association-id "$a" || true; done
              aws ec2 delete-route-table --route-table-id "$rtb" || true
            done

            SUBS=$(aws ec2 describe-subnets --filters Name=vpc-id,Values="$VPC_ID" --query 'Subnets[].SubnetId' --output text || true)
            for s in $SUBS; do aws ec2 delete-subnet --subnet-id "$s" || true; done

            SGS=$(aws ec2 describe-security-groups --filters Name=vpc-id,Values="$VPC_ID" --query 'SecurityGroups[?GroupName!=`default`].GroupId' --output text || true)
            for sg in $SGS; do aws ec2 delete-security-group --group-id "$sg" || true; done

            aws ec2 delete-vpc --vpc-id "$VPC_ID" || true
            echo "Deleted VPC $NAME ($VPC_ID)"
          }
          delete_vpc "$VPC_NAME_PRIMARY"
          delete_vpc "$VPC_NAME_SECONDARY"
